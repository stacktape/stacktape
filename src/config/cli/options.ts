import { z } from 'zod';
import { SUPPORTED_AWS_REGIONS } from '../random';

// ============ Base Option Schemas ============

export const awsRegion = z.enum(SUPPORTED_AWS_REGIONS).describe(`#### AWS Region
---
The AWS region for the operation. For a list of available regions, see the [AWS documentation](https://docs.aws.amazon.com/general/latest/gr/rande.html).`);

export const logLevel = z.enum(['info', 'debug', 'error']).describe(`#### Log Level
---
The level of logs to print to the console.
- \`info\`: Basic information about the operation.
- \`error\`: Only errors.
- \`debug\`: Detailed information for debugging.`);

export const stage = z.string().describe(`#### Stage
---
The stage for the operation (e.g., \`production\`, \`staging\`, \`dev-john\`). You can set a default stage using the \`defaults:configure\` command. The maximum length is 12 characters.`);

export const configPath = z.string().describe(`#### Config File Path
---
The path to your Stacktape configuration file, relative to the current working directory.`);

export const profile = z.string().describe(`#### AWS Profile
---
The AWS profile to use for the command. You can manage profiles using the \`aws-profile:*\` commands and set a default profile with \`defaults:configure\`.`);

export const help = z.string().describe(`#### Show Help
---
If provided, the command will not execute and will instead print help information.`);

export const awsAccount = z.string().describe(`#### AWS Account
---
The name of the AWS account to use for the operation. The account must first be connected in the [Stacktape console](https://console.stacktape.com/aws-accounts).`);

export const projectName = z.string().describe(`#### Project Name
---
The name of the Stacktape project for this operation.`);

export const resourceName = z.string().describe(`#### Resource Name
---
The name of the resource as defined in your Stacktape configuration.`);

export const currentWorkingDirectory = z.string().describe(`#### Current Working Directory
---
The working directory for the operation. All file paths in your configuration will be resolved relative to this directory. By default, this is the directory containing the configuration file.`);

export const templateId = z.string().describe(`#### Template ID
---
The ID of the template to download. You can find a list of available templates on the [Config Builder page](https://console.stacktape.com/templates).`);

export const preserveTempFiles = z.boolean().describe(`#### Preserve Temporary Files
---
If \`true\`, preserves the temporary files generated by the operation, such as the CloudFormation template and packaged resources. These files are saved to \`.stacktape/[invocation-id]\`.`);

export const disableDriftDetection = z.boolean().describe(`#### Disable Drift Detection
---
Disables detection of manual changes (drift) made to the stack outside of CloudFormation (e.g., via the AWS console or CLI). By default, Stacktape blocks updates to a stack that has drifted.`);

export const dockerArgs = z.array(z.string()).describe(`#### Docker Arguments
---
Additional arguments to pass to the \`docker run\` or \`docker build\` commands.`);

export const noCache = z.boolean().describe(`#### No Cache
---
If \`true\`, disables the use of cached artifacts and forces a fresh build of compute resources.`);

export const disableDockerRemoteCache = z.boolean().describe(`#### Disable Docker Remote Cache
---
Disables Docker layer caching using ECR as remote cache storage. By default, remote caching is enabled to speed up Docker builds by reusing layers. Set to \`true\` to disable remote caching.`);

export const disableAutoRollback = z.boolean().describe(`#### Disable Auto-Rollback
---
If \`true\`, disables automatic rollback on deployment failure.
- **With auto-rollback (default):** If a deployment fails, the stack is automatically rolled back to the last known good state.
- **Without auto-rollback:** If a deployment fails, the stack remains in the \`UPDATE_FAILED\` state. You can then either fix the issues and redeploy or manually roll back using the \`stacktape rollback\` command.`);

export const autoConfirmOperation = z.boolean().describe(`#### Auto-Confirm Operation
---
If \`true\`, automatically confirms prompts during \`deploy\` or \`delete\` operations, skipping the manual confirmation step.`);

export const showSensitiveValues = z.boolean().describe(`#### Show Sensitive Values
---
If \`true\`, includes sensitive values in the output of the \`info:stack\` and \`deploy\` commands. Be cautious when using this flag, as mishandling sensitive data can create security risks.`);

export const hotSwap = z.boolean().describe(`#### Hotswap
---
If \`true\`, attempts a faster deployment for code-only changes by updating \`functions\` and \`multi-container-workloads\` directly, without using CloudFormation. This is recommended only for development stacks. Hotswap will only be used if all stack changes are hot-swappable.`);

export const disableLayerOptimization = z.boolean().describe(`#### Disable Layer Optimization
---
If \`true\`, disables the shared Lambda layer optimization. By default, Stacktape extracts shared code into Lambda layers to reduce deployment size. Use this flag to bundle all code directly into each Lambda function.`);

export const watch = z.boolean().describe(`#### Watch
---
If \`true\`, watches for changes to your source files and automatically re-executes the compute resource when a change is detected.`);

export const container = z.string().describe(`#### Container Name
---
The name of the container as defined in your container compute resource configuration.`);

export const disableEmulation = z.boolean().describe(`#### Disable Emulation
---
Disables the automatic injection of parameters and credentials during local emulation. Use this flag if you want to run a compute resource locally that has not yet been deployed.`);

export const noTunnel = z.boolean().describe(`#### No Tunnel
---
Disables automatic tunneling for Lambda functions. In normal dev mode, Stacktape creates tunnels (using bore.pub) so that AWS Lambda functions can reach your locally emulated databases. Use this flag if you don't need Lambda-to-local connectivity or if tunneling causes issues.`);

export const remoteResources = z.array(z.string()).describe(`#### Remote Resources
---
In normal dev mode, databases and Redis run locally by default. Use this flag to connect to deployed AWS resources instead. Useful when you need to test against real data or when local emulation is insufficient. Examples: \`--remoteResources myDb\`, \`--remoteResources postgres,redis\`.`);

export const resources = z.array(z.string()).describe(`#### Resources
---
Specify which resources to run in dev mode. Can include workloads (containers, functions) and databases. If not provided, an interactive picker is shown. Use \`all\` to run all resources without prompting. Examples: \`--resources myApi\`, \`--resources myApi,myDb\`, or \`--resources all\`.`);

export const skipResources = z.array(z.string()).describe(`#### Skip Resources
---
Exclude specified resources from dev mode. All other compatible resources will run. Useful when you want to run most resources but exclude a few. Examples: \`--skipResources myHeavyDb\`, \`--skipResources fn1,fn2\`.`);

export const devMode = z.enum(['normal', 'legacy']).describe(`#### Dev Mode
---
Specifies which dev mode to use:
- \`normal\` (default): Deploys a minimal "dev stack" to AWS (IAM roles, secrets only) and runs workloads locally. Databases (PostgreSQL, MySQL, DynamoDB) and Redis are emulated locally using Docker. Tunnels are automatically created so Lambda functions can reach local databases.
- \`legacy\`: Requires an already deployed stack. Runs selected workloads locally while connecting to all deployed AWS resources. No local database emulation - uses deployed databases directly. Useful for testing against production-like data.`);

export const agent = z.boolean().describe(`#### Agent Mode
---
Optimizes CLI output for programmatic/LLM consumption:
- Forces non-TTY output mode (no spinners, animations, or interactive elements)
- Automatically confirms operations (equivalent to --autoConfirmOperation)
- Uses plain text output suitable for parsing
For dev command: also enables HTTP server for programmatic control.`);

export const agentPort = z.number().describe(`#### Agent Port
---
The port for the agent HTTP server. Providing this option enables agent mode.`);

export const agentChild = z.boolean().describe(`#### Agent Child (internal)
---
Internal flag used when spawning the daemon child process. Do not use directly.`);

export const stop = z.boolean().describe(`#### Stop Agent
---
Stops a running dev agent daemon. Reads the lock file to find the running agent and sends a stop signal.`);

export const cleanupContainers = z.boolean().describe(`#### Cleanup Containers
---
Finds and removes orphaned Stacktape dev containers (containers whose dev agent is no longer running). Use this to clean up containers left behind after a crash or improper shutdown.`);

export const freshDb = z.boolean().describe(`#### Fresh Database
---
If \`true\`, deletes existing local database data before starting. Use this to start with a clean database state.`);

export const startTime = z.union([z.number(), z.string()]).describe(`#### Start Time
---
The start time from which to print logs. This can be any format accepted by the JavaScript \`Date\` constructor.`);

export const filter = z.string().describe(`#### Filter
---
A pattern to filter the logs. Only logs matching the pattern will be printed. For more information on filter patterns, see the [AWS documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html).`);

export const raw = z.boolean().describe(`#### Raw
---
If \`true\`, prints logs in raw JSON format instead of pretty-printing them.`);

export const command = z.string().describe(`#### Command
---
This argument has different meanings depending on the command:
- With \`stacktape help\`, it specifies a command to show detailed help for.
- With \`stacktape container:session\`, it specifies a command to run inside the container to start the interactive session.`);

export const detailed = z.boolean().describe(`#### Detailed
---
If \`true\`, creates a file with detailed stack information. You can specify the output file path with \`--outFile\` and the format with \`--outFormat\`.`);

export const outFile = z.string().describe(`#### Output File
---
The path to the file where the operation output will be saved.`);

export const outFormat = z.enum(['json', 'yml']).describe(`#### Output Format
---
The format of the output file for stack information.`);

export const sourcePath = z.string().describe(`#### Source Path
---
The path to the directory to synchronize with the bucket. This can be an absolute path or relative to the current working directory.`);

export const bucketId = z.string().describe(`#### Bucket ID
---
The identifier of the destination bucket (either the AWS physical resource ID or the bucket name).`);

export const invalidateCdnCache = z.boolean().describe(`#### Invalidate CDN Cache
---
If \`true\`, invalidates the cache of the CDN connected to the bucket.`);

export const headersPreset = z.enum(['static-website', 'gatsby-static-website', 'single-page-app'])
  .describe(`#### Headers Preset
---
Configures HTTP headers of uploaded files based on a selected preset.
- \`static-website\`: Caches all content on the CDN but never in the browser.
- \`gatsby-static-website\`: Optimized for static websites built with Gatsby.
- \`single-page-app\`: Optimized for Single-Page Applications. \`index.html\` is never cached, while all other assets are cached indefinitely.`);

export const bastionResource = z.string().describe(`#### Bastion Resource Name
---
The name of the bastion resource as defined in your Stacktape configuration.`);

export const localTunnelingPort = z.number().describe(`#### Local Tunneling Port
---
Specifies the local port for tunneling when using the \`bastion:tunnel\` command. If not specified, Stacktape automatically selects an available port.`);

export const paramName = z.string().describe(`#### Parameter Name
---
The name of the resource parameter.`);

export const env = z.array(z.string()).describe(`#### Environment Variables
---
A list of environment variables for the script, in the format \`name=value\`. To add multiple variables, use this option multiple times.`);

export const scriptName = z.string().describe(`#### Script Name
---
The name of the script to run, which must be defined in the \`scripts\` section of your configuration.`);

export const assumeRoleOfResource = z.string().describe(`#### Assume Role of Resource
---
The name of the deployed resource whose IAM role should be assumed during script execution.`);

export const apiKey = z.string().describe(`#### API Key
---
Your Stacktape API key. You can get your key from the [Stacktape console](https://console.stacktape.com/api-keys).`);

export const starterId = z.string().describe(`#### Starter ID
---
The identifier of the starter project to initialize.`);

export const starterProject = z.boolean().describe(`#### Starter Project
---
If \`true\`, initializes from a starter project template instead of running the default wizard flow.`);

export const projectDirectory = z.string().describe(`#### Project Directory
---
The root directory where the project configuration should be generated.`);

export const initializeProjectTo = z.string().describe(`#### Initialize Project To
---
The directory where the starter project should be initialized. If the directory is not empty, its contents will be deleted.`);

export const configFormat = z.enum(['yaml', 'typescript']).describe(`#### Config Format
---
Format (language) used for the generated config. Options are typescript or yaml.`);

export const useAi = z.boolean().describe(`#### Use AI
---
If \`true\`, uses AI to automatically analyze your project and generate a Stacktape configuration. The AI will scan your project files, identify deployable units (services, functions, frontends), and create an appropriate configuration.`);

export const newVersion = z.string().describe(`#### New Version
---
The version of Stacktape to install.`);

export const limit = z.number().describe(`#### Limit
---
Maximum number of items to return.`);

export const stackName = z.string().describe(`#### Stack Name
---
The name of the CloudFormation stack (format: projectName-stage).`);

export const resourcesToSkip = z.array(z.string()).describe(`#### Resources to Skip
---
A list of logical resource IDs to skip during rollback. Use this when a rollback fails because certain resources cannot be restored to their previous state.`);

export const secretName = z.string().describe(`#### Secret Name
---
The name of the secret in AWS Secrets Manager.`);

export const secretValue = z.string().describe(`#### Secret Value
---
The value to store in the secret. For sensitive values, consider using --secretFile instead.`);

export const secretFile = z.string().describe(`#### Secret File
---
Path to a file whose contents will be stored as the secret value.`);

export const forceUpdate = z.boolean().describe(`#### Force Update
---
If the secret already exists, update it without prompting for confirmation.`);

export const logsQuery = z.string().describe(`#### Logs Query
---
CloudWatch Logs Insights query string. Example: "fields @timestamp, @message | filter @message like /ERROR/ | limit 50"`);

export const metric = z.string().describe(`#### Metric Name
---
CloudWatch metric name (e.g., Invocations, Errors, CPUUtilization).`);

export const period = z.number().describe(`#### Metric Period
---
Aggregation period in seconds (default: 300).`);

export const stat = z.string().describe(`#### Metric Statistic
---
Statistic to retrieve: Sum, Average, Maximum, Minimum, p99 (default: Average).`);

export const alarmState = z.string().describe(`#### Alarm State Filter
---
Filter alarms by state: OK, ALARM, or INSUFFICIENT_DATA.`);

export const background = z.boolean().describe(`#### Background Mode
---
Start the operation in background and return immediately with connection details.`);

export const execCommand = z.string().describe(`#### Execute Command
---
Command to execute in the container session.`);

export const taskArn = z.string().describe(`#### Task ARN
---
Specific ECS task ARN to connect to.`);

export const sqlQuery = z.string().describe(`#### SQL Query
---
SQL query to execute. Only read-only queries (SELECT, SHOW, DESCRIBE, EXPLAIN) are allowed.`);

export const queryTimeout = z.number().describe(`#### Query Timeout
---
Maximum time to wait for query execution in milliseconds (default: 30000).`);

export const sdkService = z.string().describe(`#### AWS SDK Service
---
AWS service name (e.g., lambda, dynamodb, s3, logs).`);

export const sdkCommand = z.string().describe(`#### AWS SDK Command
---
AWS SDK command name (e.g., ListFunctions, Scan, GetObject).`);

export const sdkInput = z.string().describe(`#### AWS SDK Input
---
JSON string containing the command input parameters.`);

export const dbOperation = z.string().describe(`#### Database Operation
---
The operation to perform (varies by database type).`);

export const dynamoPk = z.string().describe(`#### DynamoDB Partition Key
---
JSON object with partition key name and value (e.g., '{"id": "123"}').`);

export const dynamoSk = z.string().describe(`#### DynamoDB Sort Key
---
JSON object with sort key name and value (e.g., '{"timestamp": 12345}').`);

export const dbIndex = z.string().describe(`#### Database Index
---
Index name. For DynamoDB: secondary index to query. For OpenSearch: index to search.`);

export const redisKey = z.string().describe(`#### Redis Key
---
The key name to operate on.`);

export const redisPattern = z.string().describe(`#### Redis Key Pattern
---
Pattern for matching keys (default: *). Supports glob-style patterns.`);

export const redisSection = z.string().describe(`#### Redis Info Section
---
Specific section of Redis INFO output (e.g., server, memory, stats).`);

export const documentId = z.string().describe(`#### Document ID
---
ID of the document to retrieve (for OpenSearch get operation).`);

// ============ Arg Groups ============

export const universalArgs = {
  profile: profile.optional(),
  logLevel: logLevel.optional(),
  help: help.optional(),
  awsAccount: awsAccount.optional(),
  agent: agent.optional()
};

export const stackArgs = {
  stage: stage.optional(),
  region: awsRegion.optional(),
  projectName: projectName.optional()
};

export const configDependentArgs = {
  configPath: configPath.optional(),
  currentWorkingDirectory: currentWorkingDirectory.optional(),
  templateId: templateId.optional()
};

// ============ Arg Aliases ============

export const argAliases = {
  event: 'e',
  jsonEvent: 'je',
  stage: 's',
  configPath: 'cp',
  profile: 'p',
  disableDriftDetection: 'ddd',
  preserveTempFiles: 'ptf',
  region: 'r',
  resourceName: 'rn',
  watch: 'w',
  command: 'cmd',
  disableEmulation: 'de',
  portMapping: 'pm',
  logLevel: 'll',
  filter: 'f',
  startTime: 'st',
  raw: 'rw',
  dockerArgs: 'da',
  sourcePath: 'sp',
  bucketId: 'bi',
  currentWorkingDirectory: 'cwd',
  noCache: 'nc',
  env: 'env',
  detailed: 'd',
  outFile: 'out',
  outFormat: 'of',
  config: 'cfg',
  password: 'pw',
  username: 'un',
  disableAutoRollback: 'dar',
  autoConfirmOperation: 'aco',
  showSensitiveValues: 'ssv',
  fullHistory: 'fh',
  help: 'h',
  container: 'cnt',
  invalidateCdnCache: 'icc',
  headersPreset: 'hp',
  scriptName: 'scn',
  newVersion: 'nv',
  projectDirectory: 'pd',
  hotSwap: 'hs',
  apiKey: 'ak',
  awsAccount: 'aa',
  initializeProjectTo: 'ipt',
  paramName: 'pn',
  templateId: 'ti',
  bastionResource: 'br',
  projectName: 'prj',
  starterId: 'sid',
  starterProject: 'sp',
  assumeRoleOfResource: 'aror',
  configFormat: 'cf',
  localTunnelingPort: 'ltp',
  disableDockerRemoteCache: 'drc',
  resourcesToSkip: 'rts',
  disableLayerOptimization: 'dlo',
  noTunnel: 'nt',
  remoteResources: 'rr',
  resources: 'res',
  skipResources: 'sr',
  devMode: 'dm',
  agent: 'ag',
  agentPort: 'ap',
  useAi: 'ai',
  limit: 'lim',
  stackName: 'sn',
  secretName: 'secn',
  secretValue: 'secv',
  secretFile: 'secf',
  forceUpdate: 'fu',
  query: 'q',
  metric: 'met',
  period: 'per',
  stat: 'st',
  state: 'sta',
  background: 'bg',
  execCommand: 'exec',
  taskArn: 'ta'
} as const;

// ============ Combined Args Schema ============

export const allCliArgsSchema = z.object({
  help: help.optional(),
  stage: stage.optional(),
  configPath: configPath.optional(),
  disableEmulation: disableEmulation.optional(),
  profile: profile.optional(),
  disableDriftDetection: disableDriftDetection.optional(),
  preserveTempFiles: preserveTempFiles.optional(),
  region: awsRegion.optional(),
  resourceName: resourceName.optional(),
  bastionResource: bastionResource.optional(),
  paramName: paramName.optional(),
  container: container.optional(),
  watch: watch.optional(),
  noTunnel: noTunnel.optional(),
  remoteResources: remoteResources.optional(),
  command: command.optional(),
  portMapping: z.array(z.string()).optional(),
  event: z.string().optional(),
  jsonEvent: z.string().optional(),
  logLevel: logLevel.optional(),
  startTime: startTime.optional(),
  filter: filter.optional(),
  raw: raw.optional(),
  dockerArgs: dockerArgs.optional(),
  sourcePath: sourcePath.optional(),
  bucketId: bucketId.optional(),
  currentWorkingDirectory: currentWorkingDirectory.optional(),
  noCache: noCache.optional(),
  disableDockerRemoteCache: disableDockerRemoteCache.optional(),
  starterId: starterId.optional(),
  starterProject: starterProject.optional(),
  env: env.optional(),
  scriptName: scriptName.optional(),
  detailed: detailed.optional(),
  outFile: outFile.optional(),
  outFormat: outFormat.optional(),
  disableAutoRollback: disableAutoRollback.optional(),
  autoConfirmOperation: autoConfirmOperation.optional(),
  showSensitiveValues: showSensitiveValues.optional(),
  fullHistory: z.boolean().optional(),
  invalidateCdnCache: invalidateCdnCache.optional(),
  headersPreset: headersPreset.optional(),
  newVersion: newVersion.optional(),
  projectDirectory: projectDirectory.optional(),
  initializeProjectTo: initializeProjectTo.optional(),
  hotSwap: hotSwap.optional(),
  disableLayerOptimization: disableLayerOptimization.optional(),
  apiKey: apiKey.optional(),
  awsAccount: awsAccount.optional(),
  templateId: templateId.optional(),
  projectName: projectName.optional(),
  assumeRoleOfResource: assumeRoleOfResource.optional(),
  configFormat: configFormat.optional(),
  localTunnelingPort: localTunnelingPort.optional(),
  resourcesToSkip: resourcesToSkip.optional(),
  resources: resources.optional(),
  skipResources: skipResources.optional(),
  devMode: devMode.optional(),
  agent: agent.optional(),
  agentPort: agentPort.optional(),
  agentChild: agentChild.optional(),
  stop: stop.optional(),
  cleanupContainers: cleanupContainers.optional(),
  freshDb: freshDb.optional(),
  useAi: useAi.optional(),
  limit: limit.optional(),
  stackName: stackName.optional(),
  secretName: secretName.optional(),
  secretValue: secretValue.optional(),
  secretFile: secretFile.optional(),
  forceUpdate: forceUpdate.optional(),
  query: logsQuery.optional(),
  metric: metric.optional(),
  period: period.optional(),
  stat: stat.optional(),
  state: alarmState.optional(),
  background: background.optional(),
  execCommand: execCommand.optional(),
  taskArn: taskArn.optional(),
  operation: dbOperation.optional(),
  pk: dynamoPk.optional(),
  sk: dynamoSk.optional(),
  index: dbIndex.optional(),
  key: redisKey.optional(),
  pattern: redisPattern.optional(),
  section: redisSection.optional(),

  id: documentId.optional()
});

// Inferred type from Zod schema
export type StacktapeCliArgs = z.infer<typeof allCliArgsSchema>;
