"use strict";
/*
    Table.js - DynamoDB table class

    A OneTable Table represents a single (connected) DynamoDB table
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const crypto_1 = __importDefault(require("crypto"));
const UUID_js_1 = __importDefault(require("./UUID.js"));
const ULID_js_1 = __importDefault(require("./ULID.js"));
const Expression_js_1 = require("./Expression.js");
const Schema_js_1 = require("./Schema.js");
const Metrics_js_1 = require("./Metrics.js");
const Error_js_1 = require("./Error.js");
/*
    AWS V2 DocumentClient methods
 */
const DocumentClientMethods = {
    delete: 'delete',
    get: 'get',
    find: 'query',
    put: 'put',
    scan: 'scan',
    update: 'update',
    batchGet: 'batchGet',
    batchWrite: 'batchWrite',
    transactGet: 'transactGet',
    transactWrite: 'transactWrite',
};
/*
    Safety string required on API to delete a table
*/
const ConfirmRemoveTable = 'DeleteTableForever';
/*
    Crypto IV length
*/
const IV_LENGTH = 16;
const DynamoOps = {
    delete: 'deleteItem',
    get: 'getItem',
    find: 'query',
    put: 'putItem',
    scan: 'scan',
    update: 'updateItem',
    batchGet: 'batchGet',
    batchWrite: 'batchWrite',
    transactGet: 'transactGet',
    transactWrite: 'transactWrite',
};
const GenericModel = '_Generic';
/*
    Represent a single DynamoDB table
 */
class Table {
    constructor(params = {}) {
        if (!params.name) {
            throw new Error_js_1.OneArgError('Missing "name" property');
        }
        this.context = {};
        this.log = params.senselogs ? params.senselogs : new Log(params.logger);
        this.log.trace(`Loading OneTable`);
        if (params.client) {
            this.setClient(params.client);
        }
        if (params.crypto) {
            this.initCrypto(params.crypto);
            this.crypto = Object.assign(params.crypto);
            for (let [name, crypto] of Object.entries(this.crypto)) {
                crypto.secret = crypto_1.default.createHash('sha256').update(crypto.password, 'utf8').digest();
                this.crypto[name] = crypto;
                this.crypto[name].name = name;
            }
        }
        this.setParams(params);
        this.schema = new Schema_js_1.Schema(this, params.schema);
    }
    setClient(client) {
        this.client = client;
        this.V3 = client.V3;
        this.service = this.V3 ? this.client : this.client.service;
    }
    setParams(params) {
        this.createdField = params.createdField || 'created';
        this.hidden = params.hidden != null ? params.hidden : true;
        this.isoDates = params.isoDates || false;
        this.nulls = params.nulls || false;
        this.timestamps = params.timestamps != null ? params.timestamps : false;
        this.typeField = params.typeField || '_type';
        this.updatedField = params.updatedField || 'updated';
        /*
            Preserve prior values for items that may have callback functions (metrics.properties, uuid)
            If a schema loads new params, then need to preserve these callback functions.
        */
        this.name = params.name || this.name;
        if (params.uuid == 'uuid') {
            this.makeID = this.uuid;
        }
        else if (params.uuid == 'ulid') {
            this.makeID = this.ulid;
        }
        else if (!this.makeID) {
            //  Need to have uuid the default so browsers will resolve without node:crypto
            this.makeID = params.uuid || this.makeID || this.uuid;
        }
        if (params.metrics) {
            this.metrics = new Metrics_js_1.Metrics(this, params.metrics, this.metrics);
        }
        if (params.monitor) {
            this.monitor = params.monitor;
        }
        this.params = params;
    }
    getParams() {
        return {
            createdField: this.createdField,
            hidden: this.hidden,
            isoDates: this.isoDates,
            nulls: this.nulls,
            timestamps: this.timestamps,
            typeField: this.typeField,
            updatedField: this.updatedField,
            uuid: this.uuid,
        };
    }
    setSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.setSchema(schema);
        });
    }
    getCurrentSchema() {
        return this.schema.getCurrentSchema();
    }
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.getKeys();
        });
    }
    getPrimaryKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            let keys = yield this.schema.getKeys();
            return keys.primary;
        });
    }
    readSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.schema.readSchema();
        });
    }
    readSchemas() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.schema.readSchemas();
        });
    }
    removeSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.schema.removeSchema(schema);
        });
    }
    saveSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.schema.saveSchema(schema);
        });
    }
    /*
        Create a DynamoDB table. Uses the current schema index definition.
        Alternatively, params may contain standard DynamoDB createTable parameters.
    */
    createTable(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let def = {
                AttributeDefinitions: [],
                KeySchema: [],
                LocalSecondaryIndexes: [],
                GlobalSecondaryIndexes: [],
                TableName: this.name,
            };
            let provisioned = params.provisioned || params.ProvisionedThroughput;
            if (provisioned) {
                if (!provisioned.ReadCapacityUnits && !provisioned.WriteCapacityUnits) {
                    def.BillingMode = 'PAY_PER_REQUEST';
                }
                else {
                    def.ProvisionedThroughput = provisioned;
                    def.BillingMode = 'PROVISIONED';
                }
            }
            else {
                def.BillingMode = 'PAY_PER_REQUEST';
            }
            let attributes = {};
            let { indexes, models } = this.schema;
            if (!indexes) {
                throw new Error_js_1.OneArgError('Cannot create table without schema indexes');
            }
            for (let [name, index] of Object.entries(indexes)) {
                let collection, keys;
                if (name == 'primary') {
                    keys = def.KeySchema;
                }
                else {
                    if (index.hash == null || index.hash == indexes.primary.hash || index.type == 'local') {
                        collection = 'LocalSecondaryIndexes';
                        if (index.project) {
                            throw new Error_js_1.OneArgError('Unwanted project for LSI');
                        }
                    }
                    else {
                        collection = 'GlobalSecondaryIndexes';
                    }
                    keys = [];
                    let project, projection;
                    if (Array.isArray(index.project)) {
                        projection = 'INCLUDE';
                        project = index.project.filter(a => a != indexes.primary.hash && a != indexes.primary.sort);
                    }
                    else if (index.project == 'keys') {
                        projection = 'KEYS_ONLY';
                    }
                    else {
                        projection = 'ALL';
                    }
                    let projDef = {
                        IndexName: name,
                        KeySchema: keys,
                        Projection: {
                            ProjectionType: projection,
                        }
                    };
                    if (project) {
                        projDef.Projection.NonKeyAttributes = project;
                    }
                    def[collection].push(projDef);
                }
                keys.push({ AttributeName: index.hash || indexes.primary.hash, KeyType: 'HASH' });
                if (index.hash && !attributes[index.hash]) {
                    let type = this.getAttributeType(index.hash) == 'number' ? 'N' : 'S';
                    def.AttributeDefinitions.push({ AttributeName: index.hash, AttributeType: type });
                    attributes[index.hash] = true;
                }
                if (index.sort) {
                    if (!attributes[index.sort]) {
                        let type = this.getAttributeType(index.sort) == 'number' ? 'N' : 'S';
                        def.AttributeDefinitions.push({ AttributeName: index.sort, AttributeType: type });
                        attributes[index.sort] = true;
                    }
                    keys.push({ AttributeName: index.sort, KeyType: 'RANGE' });
                }
            }
            if (def.GlobalSecondaryIndexes.length == 0) {
                delete def.GlobalSecondaryIndexes;
            }
            else if (provisioned) {
                for (let index of def.GlobalSecondaryIndexes) {
                    index.ProvisionedThroughput = provisioned;
                }
            }
            if (def.LocalSecondaryIndexes.length == 0) {
                delete def.LocalSecondaryIndexes;
            }
            this.log.trace(`OneTable createTable for "${this.name}"`, { def });
            if (this.V3) {
                return yield this.service.createTable(def);
            }
            else {
                return yield this.service.createTable(def).promise();
            }
        });
    }
    getAttributeType(name) {
        for (let model of Object.values(this.schema.models)) {
            let fields = model.block.fields;
            if (fields[name]) {
                return fields[name].type;
            }
        }
        return null;
    }
    /*
        Delete the DynamoDB table forever. Be careful.
    */
    deleteTable(confirmation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (confirmation == ConfirmRemoveTable) {
                this.log.trace(`OneTable deleteTable for "${this.name}"`);
                if (this.V3) {
                    yield this.service.deleteTable({ TableName: this.name });
                }
                else {
                    yield this.service.deleteTable({ TableName: this.name }).promise();
                }
            }
            else {
                throw new Error_js_1.OneArgError(`Missing required confirmation "${ConfirmRemoveTable}"`);
            }
        });
    }
    updateTable(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let def = {
                AttributeDefinitions: [],
                GlobalSecondaryIndexUpdates: [],
                TableName: this.name,
            };
            let provisioned = params.provisioned;
            if (provisioned) {
                if (!provisioned.ReadCapacityUnits && !provisioned.WriteCapacityUnits) {
                    def.BillingMode = 'PAY_PER_REQUEST';
                }
                else {
                    def.ProvisionedThroughput = provisioned;
                    def.BillingMode = 'PROVISIONED';
                }
            }
            let indexes = this.schema.indexes;
            if (!indexes) {
                throw new Error_js_1.OneArgError('Cannot update table without schema indexes');
            }
            let create = params.create;
            if (create) {
                if (create.hash == null || create.hash == indexes.primary.hash || create.type == 'local') {
                    throw new Error_js_1.OneArgError('Cannot update table to create an LSI');
                }
                let keys = [];
                let projection, project;
                if (Array.isArray(create.project)) {
                    projection = 'INCLUDE';
                    project = create.project.filter(a => a != create.hash && a != create.sort);
                }
                else if (create.project == 'keys') {
                    projection = 'KEYS_ONLY';
                }
                else {
                    projection = 'ALL';
                }
                let projDef = {
                    IndexName: create.name,
                    KeySchema: keys,
                    Projection: {
                        ProjectionType: projection,
                    }
                };
                if (project) {
                    projDef.Projection.NonKeyAttributes = project;
                }
                keys.push({ AttributeName: create.hash, KeyType: 'HASH' });
                def.AttributeDefinitions.push({ AttributeName: create.hash, AttributeType: 'S' });
                if (create.sort) {
                    def.AttributeDefinitions.push({ AttributeName: create.sort, AttributeType: 'S' });
                    keys.push({ AttributeName: create.sort, KeyType: 'RANGE' });
                }
                def.GlobalSecondaryIndexUpdates.push({ Create: projDef });
            }
            else if (params.remove) {
                def.GlobalSecondaryIndexUpdates.push({ Delete: { IndexName: params.remove.name } });
            }
            else if (params.update) {
                let update = { Update: { IndexName: params.update.name } };
                if (provisioned) {
                    update.Update.ProvisionedThroughput = provisioned;
                }
                def.GlobalSecondaryIndexUpdates.push(update);
            }
            if (def.GlobalSecondaryIndexUpdates.length == 0) {
                delete def.GlobalSecondaryIndexUpdates;
            }
            else if (provisioned) {
                for (let index of def.GlobalSecondaryIndexes) {
                    index.ProvisionedThroughput = provisioned;
                }
            }
            this.log.trace(`OneTable updateTable for "${this.name}"`, { def });
            if (this.V3) {
                return yield this.service.updateTable(def);
            }
            else {
                return yield this.service.updateTable(def).promise();
            }
        });
    }
    /*
        Return the raw AWS table description
    */
    describeTable() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.V3) {
                return yield this.service.describeTable({ TableName: this.name });
            }
            else {
                return yield this.service.describeTable({ TableName: this.name }).promise();
            }
        });
    }
    /*
        Return true if the underlying DynamoDB table represented by this OneTable instance is present.
    */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            let results = yield this.listTables();
            return results && results.find(t => t == this.name) != null ? true : false;
        });
    }
    /*
        Return a list of tables in the AWS region described by the Table instance
    */
    listTables() {
        return __awaiter(this, void 0, void 0, function* () {
            let results;
            if (this.V3) {
                results = yield this.service.listTables({});
            }
            else {
                results = yield this.service.listTables({}).promise();
            }
            return results.TableNames;
        });
    }
    listModels() {
        return this.schema.listModels();
    }
    addModel(name, fields) {
        this.schema.addModel(name, fields);
    }
    getLog() {
        return this.log;
    }
    setLog(log) {
        this.log = log;
    }
    /*
        Thows exception if model cannot be found
     */
    getModel(name) {
        return this.schema.getModel(name);
    }
    removeModel(name) {
        return this.schema.removeModel(name);
    }
    getContext() {
        return this.context;
    }
    addContext(context = {}) {
        this.context = Object.assign(this.context, context);
        return this;
    }
    setContext(context = {}, merge = false) {
        this.context = merge ? Object.assign(this.context, context) : context;
        return this;
    }
    clearContext() {
        this.context = {};
        return this;
    }
    /*  PROTOTYPE
        Create a clone of the table with the same settings and replace the context
    */
    child(context) {
        let table = JSON.parse(JSON.stringify(this));
        table.context = context;
        return table;
    }
    /*
        High level model factory API
        The high level API is similar to the Model API except the model name is provided as the first parameter.
        This API is useful for factories
    */
    create(modelName, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this.getModel(modelName);
            return yield model.create(properties, params);
        });
    }
    find(modelName, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this.getModel(modelName);
            return yield model.find(properties, params);
        });
    }
    get(modelName, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this.getModel(modelName);
            return yield model.get(properties, params);
        });
    }
    init(modelName, properties, params) {
        let model = this.getModel(modelName);
        return model.init(properties, params);
    }
    remove(modelName, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this.getModel(modelName);
            return yield model.remove(properties, params);
        });
    }
    scan(modelName, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this.getModel(modelName);
            return yield model.scan(properties, params);
        });
    }
    update(modelName, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = this.getModel(modelName);
            return yield model.update(properties, params);
        });
    }
    execute(model, op, cmd, properties = {}, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let mark = new Date();
            let trace = { model, cmd, op, properties };
            let result;
            try {
                if (params.stats || this.metrics || this.monitor) {
                    cmd.ReturnConsumedCapacity = params.capacity || 'INDEXES';
                    cmd.ReturnItemCollectionMetrics = 'SIZE';
                }
                this.log[params.log ? 'info' : 'trace'](`OneTable "${op}" "${model}"`, { trace });
                if (this.V3) {
                    result = yield this.client[op](cmd);
                }
                else {
                    result = yield this.client[DocumentClientMethods[op]](cmd).promise();
                }
            }
            catch (err) {
                if (params.throw === false) {
                    result = {};
                }
                else if (err.code == 'ConditionalCheckFailedException' && op == 'put') {
                    //  Not a hard error -- typically part of normal operation
                    this.log.info(`Conditional check failed "${op}" on "${model}"`, { err, trace });
                    throw new Error_js_1.OneError(`Conditional create failed for "${model}"`, { code: 'Condition', trace, err });
                }
                else {
                    result = result || {};
                    result.Error = 1;
                    trace.err = err;
                    if (params.log != false) {
                        this.log.error(`OneTable exception in "${op}" on "${model}"`, { err, trace });
                    }
                    throw new Error_js_1.OneError(`OneTable execute failed "${op}" for "${model}. ${err.message}`, { err });
                }
            }
            finally {
                if (result) {
                    if (this.metrics) {
                        this.metrics.add(model, op, result, params, mark);
                    }
                    if (this.monitor) {
                        yield this.monitor(model, op, result, params, mark);
                    }
                }
            }
            if (typeof params.info == 'object') {
                params.info.operation = DynamoOps[op];
                params.info.args = cmd;
                params.info.properties = properties;
            }
            return result;
        });
    }
    /*
        The low level API does not use models. It permits the reading / writing of any attribute.
    */
    batchGet(batch, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.getOwnPropertyNames(batch).length == 0) {
                return [];
            }
            let def = batch.RequestItems[this.name];
            if (params.fields) {
                if (params.fields.indexOf(this.typeField) < 0) {
                    params.fields.push(this.typeField);
                }
                let expression = new Expression_js_1.Expression(this.schema.genericModel, 'batchGet', {}, params);
                let cmd = expression.command();
                def.ProjectionExpression = cmd.ProjectionExpression;
                def.ExpressionAttributeNames = cmd.ExpressionAttributeNames;
            }
            def.ConsistentRead = params.consistent ? true : false;
            let result = yield this.execute(GenericModel, 'batchGet', batch, {}, params);
            let response = result.Responses;
            if (params.parse && response) {
                result = [];
                for (let items of Object.values(response)) {
                    for (let item of items) {
                        item = this.unmarshall(item);
                        let type = item[this.typeField] || '_unknown';
                        let model = this.schema.models[type];
                        if (model && model != this.schema.uniqueModel) {
                            result.push(model.transformReadItem('get', item, {}, params));
                        }
                    }
                }
            }
            return result;
        });
    }
    batchWrite(batch, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.getOwnPropertyNames(batch).length == 0) {
                return {};
            }
            let more;
            do {
                more = false;
                let response = yield this.execute(GenericModel, 'batchWrite', batch, params);
                let data = response.data;
                if (data && data.UnprocessedItems && Object.keys(data.UnprocessedItems).length) {
                    batch.RequestItems = data.UnprocessedItems;
                    more = true;
                }
            } while (more);
        });
    }
    deleteItem(properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.deleteItem(properties, params);
        });
    }
    getItem(properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.getItem(properties, params);
        });
    }
    putItem(properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.putItem(properties, params);
        });
    }
    queryItems(properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.queryItems(properties, params);
        });
    }
    scanItems(properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.scanItems(properties, params);
        });
    }
    updateItem(properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.updateItem(properties, params);
        });
    }
    fetch(models, properties, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.schema.genericModel.fetch(models, properties, params);
        });
    }
    /*
        Invoke a prepared transaction. Note: transactGet does not work on non-primary indexes.
     */
    transact(op, transaction, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.execute(GenericModel, op == 'write' ? 'transactWrite' : 'transactGet', transaction, params);
            if (op == 'get') {
                if (params.parse) {
                    let items = [];
                    for (let r of result.Responses) {
                        if (r.Item) {
                            let item = this.unmarshall(r.Item);
                            let type = item[this.typeField] || '_unknown';
                            let model = this.schema.models[type];
                            if (model && model != this.schema.uniqueModel) {
                                items.push(model.transformReadItem('get', item, {}, params));
                            }
                        }
                    }
                    result = items;
                }
            }
            return result;
        });
    }
    /*
        Convert items into a map of items by model type
    */
    groupByType(items, params = {}) {
        let result = {};
        for (let item of items) {
            let type = item[this.typeField] || '_unknown';
            let list = result[type] = result[type] || [];
            let model = this.schema.models[type];
            let preparedItem;
            if (typeof params.hidden === 'boolean' && !params.hidden) {
                let fields = model.block.fields;
                preparedItem = {};
                for (let [name, field] of Object.entries(fields)) {
                    if (!(field.hidden && params.hidden !== true)) {
                        preparedItem[name] = item[name];
                    }
                }
            }
            else {
                preparedItem = item;
            }
            list.push(preparedItem);
        }
        return result;
    }
    /*
        Simple non-crypto UUID. See node-uuid if you require crypto UUIDs.
        Consider ULIDs which are crypto sortable.
    */
    uuid() {
        return (0, UUID_js_1.default)();
    }
    // Simple time-based, sortable unique ID.
    ulid() {
        return new ULID_js_1.default().toString();
    }
    setMakeID(fn) {
        this.makeID = fn;
    }
    /*
        Return the value template variable references in a list
     */
    getVars(v) {
        let list = [];
        if (Array.isArray(v)) {
            list = v;
        }
        else if (typeof v == 'string') {
            v.replace(/\${(.*?)}/g, (match, varName) => {
                list.push(varName);
            });
        }
        return list;
    }
    initCrypto(crypto) {
        this.crypto = Object.assign(crypto);
        for (let [name, crypto] of Object.entries(this.crypto)) {
            crypto.secret = crypto_1.default.createHash('sha256').update(crypto.password, 'utf8').digest();
            this.crypto[name] = crypto;
            this.crypto[name].name = name;
        }
    }
    encrypt(text, name = 'primary', inCode = 'utf8', outCode = 'base64') {
        if (text) {
            if (!this.crypto) {
                throw new Error_js_1.OneArgError('No database secret or cipher defined');
            }
            let crypto = this.crypto[name];
            if (!crypto) {
                throw new Error_js_1.OneArgError(`Database crypto not defined for ${name}`);
            }
            let iv = crypto_1.default.randomBytes(IV_LENGTH);
            let crypt = crypto_1.default.createCipheriv(crypto.cipher, crypto.secret, iv);
            let crypted = crypt.update(text, inCode, outCode) + crypt.final(outCode);
            let tag = (crypto.cipher.indexOf('-gcm') > 0) ? crypt.getAuthTag().toString(outCode) : '';
            text = `${crypto.name}:${tag}:${iv.toString('hex')}:${crypted}`;
        }
        return text;
    }
    decrypt(text, inCode = 'base64', outCode = 'utf8') {
        if (text) {
            let [name, tag, iv, data] = text.split(':');
            if (!data || !iv || !tag || !name) {
                return text;
            }
            if (!this.crypto) {
                throw new Error_js_1.OneArgError('No database secret or cipher defined');
            }
            let crypto = this.crypto[name];
            if (!crypto) {
                throw new Error_js_1.OneArgError(`Database crypto not defined for ${name}`);
            }
            iv = Buffer.from(iv, 'hex');
            let crypt = crypto_1.default.createDecipheriv(crypto.cipher, crypto.secret, iv);
            crypt.setAuthTag(Buffer.from(tag, inCode));
            text = crypt.update(data, inCode, outCode) + crypt.final(outCode);
        }
        return text;
    }
    /*
        Marshall data into and out of DynamoDB format
    */
    marshall(item) {
        let client = this.client;
        if (client.V3) {
            let options = client.params.marshall;
            if (Array.isArray(item)) {
                for (let i = 0; i < item.length; i++) {
                    item[i] = client.marshall(item[i], options);
                }
            }
            else {
                item = client.marshall(item, options);
            }
        }
        else {
            if (Array.isArray(item)) {
                for (let i = 0; i < item.length; i++) {
                    item = this.marshallv2(item);
                }
            }
            else {
                item = this.marshallv2(item);
            }
        }
        return item;
    }
    /*
        Marshall data out of DynamoDB format
    */
    unmarshall(item) {
        if (this.V3) {
            let client = this.client;
            let options = client.params.unmarshall;
            if (Array.isArray(item)) {
                for (let i = 0; i < item.length; i++) {
                    item[i] = client.unmarshall(item[i], options);
                }
            }
            else {
                item = client.unmarshall(item, options);
            }
        }
        else {
            if (Array.isArray(item)) {
                for (let i = 0; i < item.length; i++) {
                    item[i] = this.unmarshallv2(item[i]);
                }
            }
            else {
                item = this.unmarshallv2(item);
            }
        }
        return item;
    }
    marshallv2(item) {
        for (let [key, value] of Object.entries(item)) {
            if (value instanceof Set) {
                item[key] = this.client.createSet(Array.from(value));
            }
        }
        return item;
    }
    unmarshallv2(item) {
        for (let [key, value] of Object.entries(item)) {
            if (value != null && typeof value == 'object' && value.wrapperName == 'Set' && Array.isArray(value.values)) {
                let list = value.values;
                if (value.type == 'Binary') {
                    //  Match AWS SDK V3 behavior
                    list = list.map(v => new Uint8Array(v));
                }
                item[key] = new Set(list);
            }
        }
        return item;
    }
    /*
        Recursive Object.assign. Will clone dates, regexp, simple objects and arrays.
        Other class instances and primitives are copied not cloned.
        Max recursive depth of 20
    */
    assign(dest, ...sources) {
        for (let src of sources) {
            if (src) {
                dest = this.assignInner(dest, src);
            }
        }
        return dest;
    }
    assignInner(dest, src, recurse = 0) {
        if (recurse++ > 20) {
            throw new Error_js_1.OneError('Recursive merge', { code: 'Runtime' });
        }
        if (!src || !dest || typeof src != 'object') {
            return;
        }
        for (let [key, v] of Object.entries(src)) {
            if (v === undefined) {
                continue;
            }
            else if (v instanceof Date) {
                dest[key] = new Date(v);
            }
            else if (v instanceof RegExp) {
                dest[key] = new RegExp(v.source, v.flags);
            }
            else if (Array.isArray(v)) {
                if (!Array.isArray(dest[key])) {
                    dest[key] = [];
                }
                if (v.length) {
                    dest[key] = this.assignInner([key], v, recurse);
                }
            }
            else if (typeof v == 'object' && v != null && v.constructor.name == 'Object') {
                if (typeof dest[key] != 'object') {
                    dest[key] = {};
                }
                dest[key] = this.assignInner(dest[key], v, recurse);
            }
            else {
                dest[key] = v;
            }
        }
        return dest;
    }
}
exports.Table = Table;
/*
    Emulate SenseLogs API
*/
class Log {
    constructor(logger) {
        if (logger === true) {
            this.logger = this.defaultLogger;
        }
        else if (logger) {
            this.logger = logger;
        }
    }
    enabled() {
        return true;
    }
    data(message, context) {
        this.process('data', message, context);
    }
    emit(chan, message, context) {
        this.process(chan, message, context);
    }
    error(message, context) {
        this.process('error', message, context);
    }
    info(message, context) {
        this.process('info', message, context);
    }
    trace(message, context) {
        this.process('trace', message, context);
    }
    process(level, message, context) {
        if (this.logger) {
            this.logger(level, message, context);
        }
    }
    defaultLogger(level, message, context) {
        if (level == 'trace' || level == 'data') {
            //  params.log: true will cause the level to be changed to 'info'
            return;
        }
        if (context) {
            console.log(level, message, JSON.stringify(context, null, 4));
        }
        else {
            console.log(level, message);
        }
    }
}
