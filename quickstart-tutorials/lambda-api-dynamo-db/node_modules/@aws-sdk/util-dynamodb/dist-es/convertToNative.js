import { __assign, __read, __values } from "tslib";
export var convertToNative = function (data, options) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.entries(data)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            if (value !== undefined) {
                switch (key) {
                    case "NULL":
                        return null;
                    case "BOOL":
                        return Boolean(value);
                    case "N":
                        return convertNumber(value, options);
                    case "B":
                        return convertBinary(value);
                    case "S":
                        return convertString(value);
                    case "L":
                        return convertList(value, options);
                    case "M":
                        return convertMap(value, options);
                    case "NS":
                        return new Set(value.map(function (item) { return convertNumber(item, options); }));
                    case "BS":
                        return new Set(value.map(convertBinary));
                    case "SS":
                        return new Set(value.map(convertString));
                    default:
                        throw new Error("Unsupported type passed: " + key);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    throw new Error("No value defined: " + JSON.stringify(data));
};
var convertNumber = function (numString, options) {
    if (options === null || options === void 0 ? void 0 : options.wrapNumbers) {
        return { value: numString };
    }
    var num = Number(numString);
    var infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
    if ((num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num)) {
        if (typeof BigInt === "function") {
            try {
                return BigInt(numString);
            }
            catch (error) {
                throw new Error(numString + " can't be converted to BigInt. Set options.wrapNumbers to get string value.");
            }
        }
        else {
            throw new Error(numString + " is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.");
        }
    }
    return num;
};
var convertString = function (stringValue) { return stringValue; };
var convertBinary = function (binaryValue) { return binaryValue; };
var convertList = function (list, options) {
    return list.map(function (item) { return convertToNative(item, options); });
};
var convertMap = function (map, options) {
    return Object.entries(map).reduce(function (acc, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        return (__assign(__assign({}, acc), (_b = {}, _b[key] = convertToNative(value, options), _b)));
    }, {});
};
