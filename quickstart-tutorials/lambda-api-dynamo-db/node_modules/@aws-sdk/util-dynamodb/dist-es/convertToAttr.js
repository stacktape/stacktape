import { __read, __spreadArray, __values } from "tslib";
export var convertToAttr = function (data, options) {
    var _a, _b, _c, _d, _e, _f;
    if (data === undefined) {
        throw new Error("Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.");
    }
    else if (data === null && typeof data === "object") {
        return convertToNullAttr();
    }
    else if (Array.isArray(data)) {
        return convertToListAttr(data, options);
    }
    else if (((_a = data === null || data === void 0 ? void 0 : data.constructor) === null || _a === void 0 ? void 0 : _a.name) === "Set") {
        return convertToSetAttr(data, options);
    }
    else if (((_b = data === null || data === void 0 ? void 0 : data.constructor) === null || _b === void 0 ? void 0 : _b.name) === "Map") {
        return convertToMapAttrFromIterable(data, options);
    }
    else if (((_c = data === null || data === void 0 ? void 0 : data.constructor) === null || _c === void 0 ? void 0 : _c.name) === "Object" ||
        (!data.constructor && typeof data === "object")) {
        return convertToMapAttrFromEnumerableProps(data, options);
    }
    else if (isBinary(data)) {
        if (data.length === 0 && (options === null || options === void 0 ? void 0 : options.convertEmptyValues)) {
            return convertToNullAttr();
        }
        return convertToBinaryAttr(data);
    }
    else if (typeof data === "boolean" || ((_d = data === null || data === void 0 ? void 0 : data.constructor) === null || _d === void 0 ? void 0 : _d.name) === "Boolean") {
        return { BOOL: data.valueOf() };
    }
    else if (typeof data === "number" || ((_e = data === null || data === void 0 ? void 0 : data.constructor) === null || _e === void 0 ? void 0 : _e.name) === "Number") {
        return convertToNumberAttr(data);
    }
    else if (typeof data === "bigint") {
        return convertToBigIntAttr(data);
    }
    else if (typeof data === "string" || ((_f = data === null || data === void 0 ? void 0 : data.constructor) === null || _f === void 0 ? void 0 : _f.name) === "String") {
        if (data.length === 0 && (options === null || options === void 0 ? void 0 : options.convertEmptyValues)) {
            return convertToNullAttr();
        }
        return convertToStringAttr(data);
    }
    else if ((options === null || options === void 0 ? void 0 : options.convertClassInstanceToMap) && typeof data === "object") {
        return convertToMapAttrFromEnumerableProps(data, options);
    }
    throw new Error("Unsupported type passed: " + data + ". Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.");
};
var convertToListAttr = function (data, options) { return ({
    L: data
        .filter(function (item) { return !(options === null || options === void 0 ? void 0 : options.removeUndefinedValues) || ((options === null || options === void 0 ? void 0 : options.removeUndefinedValues) && item !== undefined); })
        .map(function (item) { return convertToAttr(item, options); }),
}); };
var convertToSetAttr = function (set, options) {
    var setToOperate = (options === null || options === void 0 ? void 0 : options.removeUndefinedValues) ? new Set(__spreadArray([], __read(set)).filter(function (value) { return value !== undefined; })) : set;
    if (!(options === null || options === void 0 ? void 0 : options.removeUndefinedValues) && setToOperate.has(undefined)) {
        throw new Error("Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.");
    }
    if (setToOperate.size === 0) {
        if (options === null || options === void 0 ? void 0 : options.convertEmptyValues) {
            return convertToNullAttr();
        }
        throw new Error("Pass a non-empty set, or options.convertEmptyValues=true.");
    }
    var item = setToOperate.values().next().value;
    if (typeof item === "number") {
        return {
            NS: Array.from(setToOperate)
                .map(convertToNumberAttr)
                .map(function (item) { return item.N; }),
        };
    }
    else if (typeof item === "bigint") {
        return {
            NS: Array.from(setToOperate)
                .map(convertToBigIntAttr)
                .map(function (item) { return item.N; }),
        };
    }
    else if (typeof item === "string") {
        return {
            SS: Array.from(setToOperate)
                .map(convertToStringAttr)
                .map(function (item) { return item.S; }),
        };
    }
    else if (isBinary(item)) {
        return {
            BS: Array.from(setToOperate)
                .map(convertToBinaryAttr)
                .map(function (item) { return item.B; }),
        };
    }
    else {
        throw new Error("Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.");
    }
};
var convertToMapAttrFromIterable = function (data, options) { return ({
    M: (function (data) {
        var e_1, _a;
        var map = {};
        try {
            for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var _b = __read(data_1_1.value, 2), key = _b[0], value = _b[1];
                if (typeof value !== "function" && (value !== undefined || !(options === null || options === void 0 ? void 0 : options.removeUndefinedValues))) {
                    map[key] = convertToAttr(value, options);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return map;
    })(data),
}); };
var convertToMapAttrFromEnumerableProps = function (data, options) { return ({
    M: (function (data) {
        var map = {};
        for (var key in data) {
            var value = data[key];
            if (typeof value !== "function" && (value !== undefined || !(options === null || options === void 0 ? void 0 : options.removeUndefinedValues))) {
                map[key] = convertToAttr(value, options);
            }
        }
        return map;
    })(data),
}); };
var convertToNullAttr = function () { return ({ NULL: true }); };
var convertToBinaryAttr = function (data) { return ({ B: data }); };
var convertToStringAttr = function (data) { return ({ S: data.toString() }); };
var convertToBigIntAttr = function (data) { return ({ N: data.toString() }); };
var validateBigIntAndThrow = function (errorPrefix) {
    throw new Error(errorPrefix + " " + (typeof BigInt === "function" ? "Use BigInt." : "Pass string value instead.") + " ");
};
var convertToNumberAttr = function (num) {
    if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
        .map(function (val) { return val.toString(); })
        .includes(num.toString())) {
        throw new Error("Special numeric value " + num.toString() + " is not allowed");
    }
    else if (num > Number.MAX_SAFE_INTEGER) {
        validateBigIntAndThrow("Number " + num.toString() + " is greater than Number.MAX_SAFE_INTEGER.");
    }
    else if (num < Number.MIN_SAFE_INTEGER) {
        validateBigIntAndThrow("Number " + num.toString() + " is lesser than Number.MIN_SAFE_INTEGER.");
    }
    return { N: num.toString() };
};
var isBinary = function (data) {
    var binaryTypes = [
        "ArrayBuffer",
        "Blob",
        "Buffer",
        "DataView",
        "File",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array",
    ];
    if (data === null || data === void 0 ? void 0 : data.constructor) {
        return binaryTypes.includes(data.constructor.name);
    }
    return false;
};
