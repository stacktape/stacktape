import { __awaiter, __generator } from "tslib";
var requestQueue = {};
export var updateDiscoveredEndpointInCache = function (config, options) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2, new Promise(function (resolve, reject) {
                var endpointCache = config.endpointCache;
                var cacheKey = options.cacheKey, commandName = options.commandName, identifiers = options.identifiers;
                var endpoints = endpointCache.get(cacheKey);
                if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
                    if (options.isDiscoveredEndpointRequired) {
                        if (!requestQueue[cacheKey])
                            requestQueue[cacheKey] = [];
                        requestQueue[cacheKey].push({ resolve: resolve, reject: reject });
                    }
                    else {
                        resolve();
                    }
                }
                else if (endpoints && endpoints.length > 0) {
                    resolve();
                }
                else {
                    var placeholderEndpoints_1 = [{ Address: "", CachePeriodInMinutes: 1 }];
                    endpointCache.set(cacheKey, placeholderEndpoints_1);
                    var command = new options.endpointDiscoveryCommandCtor({
                        Operation: commandName.substr(0, commandName.length - 7),
                        Identifiers: identifiers,
                    });
                    var handler = command.resolveMiddleware(options.clientStack, config, options.options);
                    handler(command)
                        .then(function (result) {
                        endpointCache.set(cacheKey, result.output.Endpoints);
                        if (requestQueue[cacheKey]) {
                            requestQueue[cacheKey].forEach(function (_a) {
                                var resolve = _a.resolve;
                                resolve();
                            });
                            delete requestQueue[cacheKey];
                        }
                        resolve();
                    })
                        .catch(function (error) {
                        var _a;
                        if (error.name === "InvalidEndpointException" || ((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 421) {
                            endpointCache.delete(cacheKey);
                        }
                        var errorToThrow = Object.assign(new Error("The operation to discover endpoint failed." +
                            " Please retry, or provide a custom endpoint and disable endpoint discovery to proceed."), { reason: error });
                        if (requestQueue[cacheKey]) {
                            requestQueue[cacheKey].forEach(function (_a) {
                                var reject = _a.reject;
                                reject(errorToThrow);
                            });
                            delete requestQueue[cacheKey];
                        }
                        if (options.isDiscoveredEndpointRequired) {
                            reject(errorToThrow);
                        }
                        else {
                            endpointCache.set(cacheKey, placeholderEndpoints_1);
                            resolve();
                        }
                    });
                }
            })];
    });
}); };
